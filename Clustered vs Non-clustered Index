INDEX -> 데이터베이스의 검색속도 향상을 위해 유지, 관리하는 자료구조

일반적인 테이블의 경우 처음부터 순차적으로 데이터를 찾기때문에 속도가 느려짐


cluster : 군집
clustered : 군집화
clustered Index : 군집화 된 인덱스


Non-clustered Index
인덱스키 값 에는 해당 데이터에 대한 포인터(주소만 저장한다.)가 존재

인덱스의 구조는 데이터 행과 독립적이다.

한 테이블에 여러개 생성이 가능하다.

    index      hashtag(주소)            value(주소)
      5           122                   하하하(122)
      14          22                    호호호(22)
     155          231                   캬캬캬(231)
      ...         ...
      232         13                    퍄퍄퍄(13)
  
순서가 없으며 주소만 가지는 해쉬태그 방식으로 데이터의 주소를 가져와 빠르게 검색 가능
한 테이블에 여러개가 존재할 수 있으며, 추가 저장공간이 필요하다.(약10%) - insert시 추가작업(인덱스생성)이 필요하다.
카디널러티 -> (Cardinality)
(주민번호와 같이 유일한 값일 경우에 높아지고, 성별과 같이 중복된 값일 수록 낮아진다.) -> 그래서 index 설정시 이 값이 높을수록
사용하기가 용이해 진다.


clustered Index -> 성능적인 이점이 있다.

데이터의 물리적인 저장방식을 맞춰줘야 한다.

데이터를 인텍스로 지정한 컬럼에 맞춰서 정렬
-> 테이블 구조에 영향을 미치며, 한 테이블당 하나만 생성가능하다.

클러스터 키로검색시 처리 성능이 매우 빠르다.

범위검색을 실시할 시 매우 효과적이다. 

index      value
  1       하하하
  2       호호호
  3       캬캬캬
  ...       ...
  
  10      퍄퍄퍄

3~6까지 index만 가져오면 되기 때문에.

약간 C++ STL의 벡터와 같은 느낌이다.

하지만, 데이터의 삽입 또는 삭제시에는 속도가 매우 느려질 수 있다.

삽입시 그 밑쪽 데이터들의 자리를 비워줘야 하며,
삭제시 그 밑쪽 데이터들을 올려줘야 하기 때문이다.



InnoBD -> Primary key는 항상 clustered index,
          unique index로 정의된 컬럼 중 하나
          보이지 않는 컬럼을 내부적으로 추가하여 사용
          
Multicolumn Index -> WHERE a ='1' AND b ='2' 와 같이 두개 이상의 colunm으로 값을 비교하는 경우


하지만 INDEX를 사용할 때도 그 특성을 알고 있어야 한다.

그리고 mysql기준 Explain aka. 실행계획

          
